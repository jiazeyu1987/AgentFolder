{
  "plan": {
    "name": "2048_game_creation_plan",
    "description": "A workflow to generate a fully functional, self-contained 2048 game in a single HTML file, including HTML structure, CSS styling, and JavaScript game logic.",
    "language": "zh-CN",
    "plan_id": "c6821cc6-5557-4bd6-85ac-e35090473451",
    "root_task_id": "b8ca18f0-da42-469b-9ed2-53e4376cb0c5",
    "created_at": "2025-12-30T15:25:23Z",
    "owner_agent_id": "xiaobo",
    "constraints": {
      "deadline": null,
      "priority": "HIGH"
    },
    "title": "创建一个2048的游戏"
  },
  "nodes": [
    {
      "id": "n1",
      "type": "template_render",
      "name": "Generate 2048 HTML Game",
      "inputs": {},
      "outputs": {
        "artifact": {
          "name": "2048_game.html",
          "format": "text/html",
          "summary": "Single-file HTML game implementing 2048 logic (grid movement, merging, scoring, game over detection) with responsive CSS styling."
        }
      },
      "params": {
        "template_name": "custom_artifact",
        "context_values": {
          "content_type": "text/html",
          "content_body": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>2048 Game</title>\n    <style>\n        body {\n            font-family: 'Arial', sans-serif;\n            text-align: center;\n            background-color: #faf8ef;\n            color: #776e65;\n            margin: 0;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            height: 100vh;\n        }\n        h1 { margin: 0; }\n        #game-container {\n            position: relative;\n            padding: 10px;\n            cursor: default;\n            touch-action: none;\n            background: #bbada0;\n            border-radius: 6px;\n            width: 300px;\n            height: 300px;\n            box-sizing: border-box;\n            margin-top: 20px;\n        }\n        .grid-container {\n            position: absolute;\n            z-index: 1;\n            display: grid;\n            grid-template-columns: repeat(4, 1fr);\n            grid-template-rows: repeat(4, 1fr);\n            gap: 10px;\n            width: 280px;\n            height: 280px;\n            top: 10px;\n            left: 10px;\n        }\n        .grid-cell {\n            background: rgba(238, 228, 218, 0.35);\n            border-radius: 3px;\n        }\n        .tile-container {\n            position: absolute;\n            z-index: 2;\n            left: 0;\n            top: 0;\n            right: 0;\n            bottom: 0;\n        }\n        .tile {\n            position: absolute;\n            width: 65px; /* (280 - 3*10) / 4 */\n            height: 65px;\n            border-radius: 3px;\n            background: #eee4da;\n            color: #776e65;\n            font-weight: bold;\n            font-size: 30px;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            transition: transform 100ms ease-in-out;\n        }\n        .tile-2 { background: #eee4da; }\n        .tile-4 { background: #ede0c8; }\n        .tile-8 { background: #f2b179; color: #f9f6f2; }\n        .tile-16 { background: #f59563; color: #f9f6f2; }\n        .tile-32 { background: #f67c5f; color: #f9f6f2; }\n        .tile-64 { background: #f65e3b; color: #f9f6f2; }\n        .tile-128 { background: #edcf72; color: #f9f6f2; font-size: 25px; }\n        .tile-256 { background: #edcc61; color: #f9f6f2; font-size: 25px; }\n        .tile-512 { background: #edc850; color: #f9f6f2; font-size: 25px; }\n        .tile-1024 { background: #edc53f; color: #f9f6f2; font-size: 20px; }\n        .tile-2048 { background: #edc22e; color: #f9f6f2; font-size: 20px; }\n        .game-intro { margin-bottom: 20px; }\n        .score-container { display: flex; justify-content: space-between; width: 300px; margin-bottom: 10px; }\n    </style>\n</head>\n<body>\n    <div class=\"game-intro\">\n        <h1>2048</h1>\n        <p>Join the numbers and get to the <strong>2048 tile!</strong></p>\n    </div>\n    <div class=\"score-container\">\n        <div>Score: <span id=\"score\">0</span></div>\n        <div><button onclick=\"game.restart()\">New Game</button></div>\n    </div>\n    <div id=\"game-container\">\n        <div class=\"grid-container\">\n            <!-- 16 grid cells -->\n            <div class=\"grid-cell\"></div><div class=\"grid-cell\"></div><div class=\"grid-cell\"></div><div class=\"grid-cell\"></div>\n            <div class=\"grid-cell\"></div><div class=\"grid-cell\"></div><div class=\"grid-cell\"></div><div class=\"grid-cell\"></div>\n            <div class=\"grid-cell\"></div><div class=\"grid-cell\"></div><div class=\"grid-cell\"></div><div class=\"grid-cell\"></div>\n            <div class=\"grid-cell\"></div><div class=\"grid-cell\"></div><div class=\"grid-cell\"></div><div class=\"grid-cell\"></div>\n        </div>\n        <div class=\"tile-container\" id=\"tile-container\"></div>\n    </div>\n    <p><strong>HOW TO PLAY:</strong> Use your arrow keys or swipe to move the tiles. Tiles with the same number merge into one when they touch. Add them up to reach 2048!</p>\n\n    <script>\n        class Game2048 {\n            constructor() {\n                this.gridSize = 4;\n                this.grid = [];\n                this.score = 0;\n                this.over = false;\n                this.won = false;\n                this.tileContainer = document.getElementById('tile-container');\n                this.scoreDisplay = document.getElementById('score');\n                this.setupInput();\n                this.restart();\n            }\n\n            restart() {\n                this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));\n                this.score = 0;\n                this.over = false;\n                this.won = false;\n                this.updateScore(0);\n                this.tileContainer.innerHTML = '';\n                this.addRandomTile();\n                this.addRandomTile();\n                this.draw();\n            }\n\n            addRandomTile() {\n                const emptyCells = [];\n                for (let r = 0; r < this.gridSize; r++) {\n                    for (let c = 0; c < this.gridSize; c++) {\n                        if (this.grid[r][c] === 0) emptyCells.push({r, c});\n                    }\n                }\n                if (emptyCells.length > 0) {\n                    const {r, c} = emptyCells[Math.floor(Math.random() * emptyCells.length)];\n                    this.grid[r][c] = Math.random() < 0.9 ? 2 : 4;\n                    this.drawTile(r, c, this.grid[r][c]);\n                }\n            }\n\n            drawTile(r, c, value) {\n                const tile = document.createElement('div');\n                tile.classList.add('tile', `tile-${value}`);\n                tile.textContent = value;\n                const gap = 10;\n                const size = 65;\n                tile.style.transform = `translate(${c * (size + gap)}px, ${r * (size + gap)}px)`;\n                this.tileContainer.appendChild(tile);\n            }\n\n            draw() {\n                this.tileContainer.innerHTML = '';\n                for (let r = 0; r < this.gridSize; r++) {\n                    for (let c = 0; c < this.gridSize; c++) {\n                        if (this.grid[r][c] !== 0) {\n                            this.drawTile(r, c, this.grid[r][c]);\n                        }\n                    }\n                }\n            }\n\n            updateScore(added) {\n                this.score += added;\n                this.scoreDisplay.textContent = this.score;\n            }\n\n            move(direction) {\n                if (this.over) return;\n                let moved = false;\n                let scoreAdded = 0;\n                \n                // vectors\n                const vectors = {\n                    'ArrowUp': {x: 0, y: -1},\n                    'ArrowRight': {x: 1, y: 0},\n                    'ArrowDown': {x: 0, y: 1},\n                    'ArrowLeft': {x: -1, y: 0}\n                };\n                const vector = vectors[direction];\n\n                // Traversal order\n                let traversals = {x: [], y: []};\n                for (let pos = 0; pos < this.gridSize; pos++) {\n                    traversals.x.push(pos);\n                    traversals.y.push(pos);\n                }\n                if (vector.x === 1) traversals.x = traversals.x.reverse();\n                if (vector.y === 1) traversals.y = traversals.y.reverse();\n\n                // Prepare merged flags\n                let merged = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(false));\n\n                traversals.x.forEach(x => {\n                    traversals.y.forEach(y => {\n                        let r = y;\n                        let c = x;\n                        if (this.grid[r][c] !== 0) {\n                            let next = {r: r + vector.y, c: c + vector.x};\n                            while (\n                                next.r >= 0 && next.r < this.gridSize &&\n                                next.c >= 0 && next.c < this.gridSize &&\n                                this.grid[next.r][next.c] === 0\n                            ) {\n                                next.r += vector.y;\n                                next.c += vector.x;\n                            }\n                            // Check merge\n                            let mergedCell = {r: next.r, c: next.c};\n                            // Move back one step if we hit boundary or occupied\n                            if (next.r < 0 || next.r >= this.gridSize || next.c < 0 || next.c >= this.gridSize || this.grid[next.r][next.c] !== this.grid[r][c]) {\n                                // We didn't land on a mergeable tile, so we are at the previous empty slot\n                                mergedCell.r -= vector.y;\n                                mergedCell.c -= vector.x;\n                            }\n                            \n                            // Bounds check for final position\n                            if (mergedCell.r < 0) mergedCell.r = 0;\n                            if (mergedCell.r >= this.gridSize) mergedCell.r = this.gridSize - 1;\n                            if (mergedCell.c < 0) mergedCell.c = 0;\n                            if (mergedCell.c >= this.gridSize) mergedCell.c = this.gridSize - 1;\n\n                            if (mergedCell.r !== r || mergedCell.c !== c) {\n                                // Check if valid merge\n                                if (this.grid[mergedCell.r][mergedCell.c] === this.grid[r][c] && !merged[mergedCell.r][mergedCell.c]) {\n                                    // Merge\n                                    let newValue = this.grid[r][c] * 2;\n                                    this.grid[mergedCell.r][mergedCell.c] = newValue;\n                                    this.grid[r][c] = 0;\n                                    merged[mergedCell.r][mergedCell.c] = true;\n                                    scoreAdded += newValue;\n                                    if (newValue === 2048) this.won = true;\n                                    moved = true;\n                                } else if (this.grid[mergedCell.r][mergedCell.c] === 0) {\n                                    // Just move\n                                    this.grid[mergedCell.r][mergedCell.c] = this.grid[r][c];\n                                    this.grid[r][c] = 0;\n                                    moved = true;\n                                }\n                            }\n                        }\n                    });\n                });\n\n                if (moved) {\n                    this.addRandomTile();\n                    this.updateScore(scoreAdded);\n                    this.draw();\n                    if (!this.movesAvailable()) {\n                        this.over = true;\n                        alert(\"Game Over!\");\n                    }\n                }\n            }\n\n            movesAvailable() {\n                for (let r = 0; r < this.gridSize; r++) {\n                    for (let c = 0; c < this.gridSize; c++) {\n                        if (this.grid[r][c] === 0) return true;\n                        if (c < this.gridSize - 1 && this.grid[r][c] === this.grid[r][c+1]) return true;\n                        if (r < this.gridSize - 1 && this.grid[r][c] === this.grid[r+1][c]) return true;\n                    }\n                }\n                return false;\n            }\n\n            setupInput() {\n                document.addEventListener('keydown', (e) => {\n                    const map = {\n                        'ArrowUp': 'ArrowUp',\n                        'ArrowRight': 'ArrowRight',\n                        'ArrowDown': 'ArrowDown',\n                        'ArrowLeft': 'ArrowLeft',\n                        'w': 'ArrowUp',\n                        'd': 'ArrowRight',\n                        's': 'ArrowDown',\n                        'a': 'ArrowLeft'\n                    };\n                    if (map[e.key]) {\n                        e.preventDefault();\n                        this.move(map[e.key]);\n                    }\n                });\n                \n                // Touch support\n                let touchStartClientX, touchStartClientY;\n                const gameContainer = document.getElementById('game-container');\n                \n                gameContainer.addEventListener('touchstart', (e) => {\n                    if (e.touches.length > 1) return;\n                    touchStartClientX = e.touches[0].clientX;\n                    touchStartClientY = e.touches[0].clientY;\n                    e.preventDefault();\n                }, {passive: false});\n\n                gameContainer.addEventListener('touchmove', (e) => {\n                    e.preventDefault();\n                }, {passive: false});\n\n                gameContainer.addEventListener('touchend', (e) => {\n                    if (e.touches.length > 0) return;\n                    let dx = e.changedTouches[0].clientX - touchStartClientX;\n                    let dy = e.changedTouches[0].clientY - touchStartClientY;\n                    let absDx = Math.abs(dx);\n                    let absDy = Math.abs(dy);\n\n                    if (Math.max(absDx, absDy) > 10) {\n                        if (absDx > absDy) {\n                            this.move(dx > 0 ? 'ArrowRight' : 'ArrowLeft');\n                        } else {\n                            this.move(dy > 0 ? 'ArrowDown' : 'ArrowUp');\n                        }\n                    }\n                });\n            }\n        }\n\n        const game = new Game2048();\n    </script>\n</body>\n</html>"
        }
      },
      "task_id": "605584e1-ec2c-4ab9-8e93-26a68b1b259f",
      "plan_id": "c6821cc6-5557-4bd6-85ac-e35090473451",
      "node_type": "ACTION",
      "title": "Task 1",
      "owner_agent_id": "xiaobo",
      "priority": 0,
      "tags": []
    },
    {
      "task_id": "b8ca18f0-da42-469b-9ed2-53e4376cb0c5",
      "plan_id": "c6821cc6-5557-4bd6-85ac-e35090473451",
      "node_type": "GOAL",
      "title": "Root Task",
      "goal_statement": null,
      "rationale": "Autocreated placeholder node for referential integrity.",
      "owner_agent_id": "xiaobo",
      "priority": 0,
      "tags": [
        "autofix",
        "placeholder"
      ]
    }
  ],
  "edges": [],
  "requirements": []
}